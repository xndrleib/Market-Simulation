"""Limit order book implementation."""

from __future__ import annotations

from typing import Any, Iterable, Optional

from .types import Order, Trade


class OrderBook:
    """Simple price-time-priority limit order book.

    Notes
    -----
    - Bids are sorted by descending price, then ascending time.
    - Asks are sorted by ascending price, then ascending time.
    - Market orders are matched immediately; unfilled remainder is discarded.
    """

    def __init__(self) -> None:
        self.bids: list[Order] = []
        self.asks: list[Order] = []
        self.order_lookup: dict[int, Order] = {}
        self.trades: list[Trade] = []

    def best_bid(self) -> Optional[Order]:
        """Return the current best bid order, if any."""

        return self.bids[0] if self.bids else None

    def best_ask(self) -> Optional[Order]:
        """Return the current best ask order, if any."""

        return self.asks[0] if self.asks else None

    def mid_price(self, fallback_price: float) -> float:
        """Compute the mid-price from best bid/ask.

        Parameters
        ----------
        fallback_price
            Price to use when the book is empty.
        """

        bid = self.best_bid()
        ask = self.best_ask()
        if bid is None and ask is None:
            return fallback_price
        if bid is None:
            return float(ask.price)  # type: ignore[return-value]
        if ask is None:
            return float(bid.price)  # type: ignore[return-value]
        return 0.5 * (float(bid.price) + float(ask.price))

    def cancel_agent_orders(self, agent_id: int) -> None:
        """Remove all resting orders belonging to an agent."""

        self.bids = [order for order in self.bids if order.agent_id != agent_id]
        self.asks = [order for order in self.asks if order.agent_id != agent_id]
        for oid, order in list(self.order_lookup.items()):
            if order.agent_id == agent_id:
                self.order_lookup.pop(oid, None)

    def _add_limit_order_to_book(self, order: Order) -> None:
        if order.is_market:
            raise ValueError("Market orders cannot be added to the book")
        if order.price is None:
            raise ValueError("Limit orders must have a price")

        book_side = self.bids if order.side == "BUY" else self.asks
        inserted = False

        for i, existing in enumerate(book_side):
            if order.side == "BUY":
                if (order.price > existing.price) or (
                    order.price == existing.price and order.time < existing.time
                ):
                    book_side.insert(i, order)
                    inserted = True
                    break
            else:
                if (order.price < existing.price) or (
                    order.price == existing.price and order.time < existing.time
                ):
                    book_side.insert(i, order)
                    inserted = True
                    break

        if not inserted:
            book_side.append(order)

        self.order_lookup[order.id] = order

    def process_order(self, order: Order) -> list[Trade]:
        """Match an incoming order against the book and record trades.

        Parameters
        ----------
        order
            Incoming order to process.

        Returns
        -------
        list[Trade]
            Trades generated by the order.
        """

        trades: list[Trade] = []
        remaining_qty = order.quantity

        if order.side == "BUY":
            book_side = self.asks

            def crossing(best: Order) -> bool:
                if order.is_market:
                    return True
                return order.price is not None and best.price is not None and order.price >= best.price

        else:
            book_side = self.bids

            def crossing(best: Order) -> bool:
                if order.is_market:
                    return True
                return order.price is not None and best.price is not None and order.price <= best.price

        while remaining_qty > 0 and book_side:
            best = book_side[0]
            if not crossing(best):
                break

            trade_qty = min(remaining_qty, best.quantity)
            trade_price = float(best.price) if best.price is not None else 0.0
            remaining_qty -= trade_qty
            best.quantity -= trade_qty

            if order.side == "BUY":
                buy_id = order.agent_id
                sell_id = best.agent_id
            else:
                buy_id = best.agent_id
                sell_id = order.agent_id

            trade = Trade(
                time=order.time,
                price=trade_price,
                quantity=trade_qty,
                buy_agent=buy_id,
                sell_agent=sell_id,
            )
            trades.append(trade)
            self.trades.append(trade)

            if best.quantity == 0:
                self.order_lookup.pop(best.id, None)
                book_side.pop(0)

        if not order.is_market and remaining_qty > 0:
            order.quantity = remaining_qty
            self._add_limit_order_to_book(order)

        return trades

    def iter_orders(self) -> Iterable[Order]:
        """Iterate over all resting orders."""

        yield from self.bids
        yield from self.asks

    def snapshot(self) -> dict[str, list[dict[str, Any]]]:
        """Return a serializable snapshot of the book."""

        def to_dict(order: Order) -> dict[str, Any]:
            return {
                "id": order.id,
                "time": order.time,
                "agent_id": order.agent_id,
                "side": order.side,
                "price": order.price,
                "quantity": order.quantity,
                "is_market": order.is_market,
            }

        return {
            "bids": [to_dict(order) for order in self.bids],
            "asks": [to_dict(order) for order in self.asks],
        }
